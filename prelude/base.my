# Logical unary not.
fn unary!(v)
  if v then
    0
  else
    1;

# Unary negate.
fn unary-(v)
  0-v;

# Define > with the same precedence as <.
fn binary> 10 (LHS RHS)
  RHS < LHS;

# Binary logical or, which does not short circuit.
fn binary| 5 (LHS RHS)
  if LHS then
    1
  else if RHS then
    1
  else
    0;

# Binary logical and, which does not short circuit.
fn binary& 6 (LHS RHS)
  if !LHS then
    0
  else
    !!RHS;

# Define = with slightly lower precedence than relationals.
fn binary = 9 (LHS RHS)
  !(LHS < RHS | LHS > RHS);

# Define ':' for sequencing: as a low-precedence operator that ignores operands
# and just returns the RHS.
fn binary : 1 (x y) y;
